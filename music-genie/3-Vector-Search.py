# Databricks notebook source
# MAGIC %md
# MAGIC ## Let's put everything together!
# MAGIC So far we have:
# MAGIC 1. Built a Langchain model incorporating the Databricks Foundation model DBRX and custom functions (Notebook 1-Emotion-Labels-Model)
# MAGIC 2. Created a dataset of song lyrics and augmented with emotions generated by our model (Notebook-1-Emotion-Labels-Model)
# MAGIC 3. Downloaded and served an embedding model (Notebook 2-Embedding-Model)
# MAGIC 4. Embedded the generated song emotions and stored them in a vector database (Notebook 2-Embedding-Model)
# MAGIC 5. Created a vector search endpoint
# MAGIC
# MAGIC Now we want to bring all of these elements together into an app that will:
# MAGIC 1. Accept a user's input
# MAGIC 2. Use the emotion-label model to code the user's input with ten emotions
# MAGIC 3. Embed the user's emotions by calling the embedding endpoint
# MAGIC 4. Run a similarity search on those emotions against our song emotions vector database
# MAGIC 5. Return the most similar songs back to the user

# COMMAND ----------

# MAGIC %%capture
# MAGIC %pip install databricks-vectorsearch==0.22 databricks-sdk==0.12.0 mlflow[databricks] mlflow==2.9.2
# MAGIC dbutils.library.restartPython()

# COMMAND ----------

# MAGIC %run ./variables

# COMMAND ----------

# MAGIC %md
# MAGIC ### Accept User Input and Return Related Songs

# COMMAND ----------

import os
import requests
import numpy as np
import pandas as pd
import json
import string
from databricks.vector_search.client import VectorSearchClient

# initiate the vector search class
host = "https://" + spark.conf.get("spark.databricks.workspaceUrl")
vsc = VectorSearchClient(workspace_url=host, disable_notice=True)

# get vector search index
# vector_search_endpoint_name = 'music_genie_vector_search_endpoint'
vector_search_endpoint_name = 'one-env-shared-endpoint-4' # using a shared endpoint in Field-Eng-East
vs_index_full_name = f"{catalog}.{schema}.spotify_song_emotions_embeddings_index"
index = vsc.get_index(index_name=vs_index_full_name, endpoint_name=vector_search_endpoint_name)

# COMMAND ----------

# load the langchain model
music_genie_model = mlflow.pyfunc.load_model('runs:/0f25514042ba4d25be3fa771d777f7b9/music_genie_llm')
# test model
music_genie_model.predict({"input": "Today is going to be a great day!"})

# COMMAND ----------

# Get the API endpoint and token for the current notebook context
API_ROOT = dbutils.notebook.entry_point.getDbutils().notebook().getContext().apiUrl().get() 
API_TOKEN = dbutils.notebook.entry_point.getDbutils().notebook().getContext().apiToken().get()

def get_embeddings(data_json: dict):
  headers = {"Context-Type": "text/json", "Authorization": f"Bearer {API_TOKEN}"}
  data = {"inputs": [user_input]}
  response = requests.post(
      url=f"{API_ROOT}/serving-endpoints/{embedding_model_serving_endpoint_name}/invocations", json=data, headers=headers
  )
  if response.status_code != 200:
      raise Exception(f"Request failed with status {response.status_code}, {response.text}")
  return response.json()['predictions']

def music_genie(user_input):
  '''Cleaning up the user input and calling the langchain model (which uses a Databricks Foundation Model)'''
  clean_user_input = user_input.translate(str.maketrans('', '', string.punctuation))
  user_emotions = music_genie_model.predict({"input": clean_user_input})
  emotions_json = {
                    "dataframe_split": {
                      "data": [
                          user_emotions
                      ], 
                    } 
                  }
  user_emotions_embeddings = get_embeddings(emotions_json)
  
  # similarity search
  query_resp = index.similarity_search(
                            query_vector=user_emotions_embeddings[0],
                            columns=["artist", "song", "link", "llm_labeled_emotions"],
                            num_results=10,
                            )

  # return response from vector search
  return {"user_emotions": user_emotions, "vector_search_response": query_resp['result']['data_array']}

# COMMAND ----------

user_input = "I am in love!"
music_genie(user_input)

# COMMAND ----------

user_input = "It's been a long, rainy winter."
music_genie(user_input)

# COMMAND ----------

user_input = "The barista got my order wrong. I am furious."
music_genie(user_input)

# COMMAND ----------

user_input = "I can't believe that awful man won the lottery. Life is unfair."
music_genie(user_input)

# COMMAND ----------

# MAGIC %md
# MAGIC Notes for Music Genie improvement:
# MAGIC - Classify holiday songs differently (Christmas songs come up frequently)
# MAGIC - For our purposes, remove any inappropriate songs from the dataset 
# MAGIC

# COMMAND ----------


